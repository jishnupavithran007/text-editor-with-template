{
  "version": 3,
  "sources": ["../../@lexical/mark/LexicalMark.dev.mjs"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nimport { ElementNode, $isRangeSelection, $applyNodeReplacement, defineExtension, $createRangeSelection, $isElementNode, $isTextNode, $isDecoratorNode } from 'lexical';\nimport { addClassNamesToElement, removeClassNamesFromElement } from '@lexical/utils';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst NO_IDS = [];\n\n/** @noInheritDoc */\nclass MarkNode extends ElementNode {\n  /** @internal */\n  __ids;\n  static getType() {\n    return 'mark';\n  }\n  static clone(node) {\n    return new MarkNode(node.__ids, node.__key);\n  }\n  static importDOM() {\n    return null;\n  }\n  static importJSON(serializedNode) {\n    return $createMarkNode().updateFromJSON(serializedNode);\n  }\n  updateFromJSON(serializedNode) {\n    return super.updateFromJSON(serializedNode).setIDs(serializedNode.ids);\n  }\n  exportJSON() {\n    return {\n      ...super.exportJSON(),\n      ids: this.getIDs()\n    };\n  }\n  constructor(ids = NO_IDS, key) {\n    super(key);\n    this.__ids = ids;\n  }\n  createDOM(config) {\n    const element = document.createElement('mark');\n    addClassNamesToElement(element, config.theme.mark);\n    if (this.__ids.length > 1) {\n      addClassNamesToElement(element, config.theme.markOverlap);\n    }\n    return element;\n  }\n  updateDOM(prevNode, element, config) {\n    const prevIDs = prevNode.__ids;\n    const nextIDs = this.__ids;\n    const prevIDsCount = prevIDs.length;\n    const nextIDsCount = nextIDs.length;\n    const overlapTheme = config.theme.markOverlap;\n    if (prevIDsCount !== nextIDsCount) {\n      if (prevIDsCount === 1) {\n        if (nextIDsCount === 2) {\n          addClassNamesToElement(element, overlapTheme);\n        }\n      } else if (nextIDsCount === 1) {\n        removeClassNamesFromElement(element, overlapTheme);\n      }\n    }\n    return false;\n  }\n  hasID(id) {\n    return this.getIDs().includes(id);\n  }\n  getIDs() {\n    return Array.from(this.getLatest().__ids);\n  }\n  setIDs(ids) {\n    const self = this.getWritable();\n    self.__ids = ids;\n    return self;\n  }\n  addID(id) {\n    const self = this.getWritable();\n    return self.__ids.includes(id) ? self : self.setIDs([...self.__ids, id]);\n  }\n  deleteID(id) {\n    const self = this.getWritable();\n    const idx = self.__ids.indexOf(id);\n    if (idx === -1) {\n      return self;\n    }\n    const ids = Array.from(self.__ids);\n    ids.splice(idx, 1);\n    return self.setIDs(ids);\n  }\n  insertNewAfter(selection, restoreSelection = true) {\n    const markNode = $createMarkNode(this.__ids);\n    this.insertAfter(markNode, restoreSelection);\n    return markNode;\n  }\n  canInsertTextBefore() {\n    return false;\n  }\n  canInsertTextAfter() {\n    return false;\n  }\n  canBeEmpty() {\n    return false;\n  }\n  isInline() {\n    return true;\n  }\n  extractWithChild(child, selection, destination) {\n    if (!$isRangeSelection(selection) || destination === 'html') {\n      return false;\n    }\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n    const isBackward = selection.isBackward();\n    const selectionLength = isBackward ? anchor.offset - focus.offset : focus.offset - anchor.offset;\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selectionLength;\n  }\n  excludeFromCopy(destination) {\n    return destination !== 'clone';\n  }\n}\nfunction $createMarkNode(ids = NO_IDS) {\n  return $applyNodeReplacement(new MarkNode(ids));\n}\nfunction $isMarkNode(node) {\n  return node instanceof MarkNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $unwrapMarkNode(node) {\n  const children = node.getChildren();\n  let target = null;\n  for (let i = 0; i < children.length; i++) {\n    const child = children[i];\n    if (target === null) {\n      node.insertBefore(child);\n    } else {\n      target.insertAfter(child);\n    }\n    target = child;\n  }\n  node.remove();\n}\nfunction $wrapSelectionInMarkNode(selection, isBackward, id, createNode) {\n  // Force a forwards selection since append is used, ignore the argument.\n  // A new selection is used to avoid side-effects of flipping the given\n  // selection\n  const forwardSelection = $createRangeSelection();\n  const [startPoint, endPoint] = selection.isBackward() ? [selection.focus, selection.anchor] : [selection.anchor, selection.focus];\n  forwardSelection.anchor.set(startPoint.key, startPoint.offset, startPoint.type);\n  forwardSelection.focus.set(endPoint.key, endPoint.offset, endPoint.type);\n  let currentNodeParent;\n  let lastCreatedMarkNode;\n\n  // Note that extract will split text nodes at the boundaries\n  const nodes = forwardSelection.extract();\n  // We only want wrap adjacent text nodes, line break nodes\n  // and inline element nodes. For decorator nodes and block\n  // element nodes, we step out of their boundary and start\n  // again after, if there are more nodes.\n  for (const node of nodes) {\n    if ($isElementNode(lastCreatedMarkNode) && lastCreatedMarkNode.isParentOf(node)) {\n      // If the current node is a child of the last created mark node, there is nothing to do here\n      continue;\n    }\n    let targetNode = null;\n    if ($isTextNode(node)) {\n      // Case 1: The node is a text node and we can include it\n      targetNode = node;\n    } else if ($isMarkNode(node)) {\n      // Case 2: the node is a mark node and we can ignore it as a target,\n      // moving on to its children. Note that when we make a mark inside\n      // another mark, it may ultimately be unnested by a call to\n      // `registerNestedElementResolver<MarkNode>` somewhere else in the\n      // codebase.\n      continue;\n    } else if (($isElementNode(node) || $isDecoratorNode(node)) && node.isInline()) {\n      // Case 3: inline element/decorator nodes can be added in their entirety\n      // to the new mark\n      targetNode = node;\n    }\n    if (targetNode !== null) {\n      // Now that we have a target node for wrapping with a mark, we can run\n      // through special cases.\n      if (targetNode && targetNode.is(currentNodeParent)) {\n        // The current node is a child of the target node to be wrapped, there\n        // is nothing to do here.\n        continue;\n      }\n      const parentNode = targetNode.getParent();\n      if (parentNode == null || !parentNode.is(currentNodeParent)) {\n        // If the parent node is not the current node's parent node, we can\n        // clear the last created mark node.\n        lastCreatedMarkNode = undefined;\n      }\n      currentNodeParent = parentNode;\n      if (lastCreatedMarkNode === undefined) {\n        // If we don't have a created mark node, we can make one\n        const createMarkNode = createNode || $createMarkNode;\n        lastCreatedMarkNode = createMarkNode([id]);\n        targetNode.insertBefore(lastCreatedMarkNode);\n      }\n\n      // Add the target node to be wrapped in the latest created mark node\n      lastCreatedMarkNode.append(targetNode);\n    } else {\n      // If we don't have a target node to wrap we can clear our state and\n      // continue on with the next node\n      currentNodeParent = undefined;\n      lastCreatedMarkNode = undefined;\n    }\n  }\n  // Make selection collapsed at the end\n  if ($isElementNode(lastCreatedMarkNode)) {\n    if (isBackward) {\n      lastCreatedMarkNode.selectStart();\n    } else {\n      lastCreatedMarkNode.selectEnd();\n    }\n  }\n}\nfunction $getMarkIDs(node, offset) {\n  let currentNode = node;\n  while (currentNode !== null) {\n    if ($isMarkNode(currentNode)) {\n      return currentNode.getIDs();\n    } else if ($isTextNode(currentNode) && offset === currentNode.getTextContentSize()) {\n      const nextSibling = currentNode.getNextSibling();\n      if ($isMarkNode(nextSibling)) {\n        return nextSibling.getIDs();\n      }\n    }\n    currentNode = currentNode.getParent();\n  }\n  return null;\n}\n\n/**\n * Configures {@link MarkNode}\n */\nconst MarkExtension = defineExtension({\n  name: '@lexical/mark',\n  nodes: [MarkNode]\n});\n\nexport { $createMarkNode, $getMarkIDs, $isMarkNode, $unwrapMarkNode, $wrapSelectionInMarkNode, MarkExtension, MarkNode };\n"],
  "mappings": "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",
  "names": []
}
