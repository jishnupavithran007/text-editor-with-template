import {
  $isMarkNode
} from "./chunk-L3S2R26Q.js";
import {
  $isTableSelection
} from "./chunk-3277PAMW.js";
import {
  $isLinkNode
} from "./chunk-WVBUWEGB.js";
import {
  $generateHtmlFromNodes
} from "./chunk-HC66QSXI.js";
import "./chunk-XZ4UOL56.js";
import {
  mergeRegister
} from "./chunk-GVKTXHIP.js";
import {
  $getRoot,
  $getSelection,
  $isElementNode,
  $isNodeSelection,
  $isParagraphNode,
  $isRangeSelection,
  $isTextNode,
  COMMAND_PRIORITY_CRITICAL
} from "./chunk-CMQWNATU.js";
import {
  require_jsx_runtime
} from "./chunk-XO4JX7VM.js";
import {
  require_react
} from "./chunk-PSQR3SVX.js";
import {
  __toESM
} from "./chunk-5WRI5ZAA.js";

// node_modules/@lexical/devtools-core/LexicalDevtoolsCore.dev.mjs
var import_react = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var NON_SINGLE_WIDTH_CHARS_REPLACEMENT = Object.freeze({
  "	": "\\t",
  "\n": "\\n"
});
var NON_SINGLE_WIDTH_CHARS_REGEX = new RegExp(Object.keys(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).join("|"), "g");
var SYMBOLS = Object.freeze({
  ancestorHasNextSibling: "|",
  ancestorIsLastChild: " ",
  hasNextSibling: "├",
  isLastChild: "└",
  selectedChar: "^",
  selectedLine: ">"
});
var FORMAT_PREDICATES = [(node) => node.hasFormat("bold") && "Bold", (node) => node.hasFormat("code") && "Code", (node) => node.hasFormat("italic") && "Italic", (node) => node.hasFormat("strikethrough") && "Strikethrough", (node) => node.hasFormat("subscript") && "Subscript", (node) => node.hasFormat("superscript") && "Superscript", (node) => node.hasFormat("underline") && "Underline", (node) => node.hasFormat("highlight") && "Highlight"];
var FORMAT_PREDICATES_PARAGRAPH = [(node) => node.hasTextFormat("bold") && "Bold", (node) => node.hasTextFormat("code") && "Code", (node) => node.hasTextFormat("italic") && "Italic", (node) => node.hasTextFormat("strikethrough") && "Strikethrough", (node) => node.hasTextFormat("subscript") && "Subscript", (node) => node.hasTextFormat("superscript") && "Superscript", (node) => node.hasTextFormat("underline") && "Underline", (node) => node.hasTextFormat("highlight") && "Highlight"];
var DETAIL_PREDICATES = [(node) => node.isDirectionless() && "Directionless", (node) => node.isUnmergeable() && "Unmergeable"];
var MODE_PREDICATES = [(node) => node.isToken() && "Token", (node) => node.isSegmented() && "Segmented"];
function generateContent(editor, commandsLog, exportDOM, customPrintNode, obfuscateText = false) {
  const editorState = editor.getEditorState();
  const editorConfig = editor._config;
  const compositionKey = editor._compositionKey;
  const editable = editor._editable;
  if (exportDOM) {
    let htmlString = "";
    editorState.read(() => {
      htmlString = printPrettyHTML($generateHtmlFromNodes(editor));
    });
    return htmlString;
  }
  let res = " root\n";
  const selectionString = editorState.read(() => {
    const selection = $getSelection();
    visitTree($getRoot(), (node, indent) => {
      const nodeKey = node.getKey();
      const nodeKeyDisplay = `(${nodeKey})`;
      const typeDisplay = node.getType() || "";
      const isSelected = node.isSelected();
      res += `${isSelected ? SYMBOLS.selectedLine : " "} ${indent.join(" ")} ${nodeKeyDisplay} ${typeDisplay} ${printNode(node, customPrintNode, obfuscateText)}
`;
      res += $printSelectedCharsLine({
        indent,
        isSelected,
        node,
        nodeKeyDisplay,
        selection,
        typeDisplay
      });
    });
    return selection === null ? ": null" : $isRangeSelection(selection) ? printRangeSelection(selection) : $isTableSelection(selection) ? printTableSelection(selection) : printNodeSelection(selection);
  });
  res += "\n selection" + selectionString;
  res += "\n\n commands:";
  if (commandsLog.length) {
    for (const {
      index,
      type,
      payload
    } of commandsLog) {
      res += `
  └ ${index}. { type: ${type}, payload: ${payload instanceof Event ? payload.constructor.name : payload} }`;
    }
  } else {
    res += "\n  └ None dispatched.";
  }
  const {
    version
  } = editor.constructor;
  res += `

 editor${version ? ` (v${version})` : ""}:`;
  res += `
  └ namespace ${editorConfig.namespace}`;
  if (compositionKey !== null) {
    res += `
  └ compositionKey ${compositionKey}`;
  }
  res += `
  └ editable ${String(editable)}`;
  return res;
}
function printRangeSelection(selection) {
  let res = "";
  const formatText = printFormatProperties(selection);
  res += `: range ${formatText !== "" ? `{ ${formatText} }` : ""} ${selection.style !== "" ? `{ style: ${selection.style} } ` : ""}`;
  const anchor = selection.anchor;
  const focus = selection.focus;
  const anchorOffset = anchor.offset;
  const focusOffset = focus.offset;
  res += `
  ├ anchor { key: ${anchor.key}, offset: ${anchorOffset === null ? "null" : anchorOffset}, type: ${anchor.type} }`;
  res += `
  └ focus { key: ${focus.key}, offset: ${focusOffset === null ? "null" : focusOffset}, type: ${focus.type} }`;
  return res;
}
function printNodeSelection(selection) {
  if (!$isNodeSelection(selection)) {
    return "";
  }
  return `: node
  └ [${Array.from(selection._nodes).join(", ")}]`;
}
function printTableSelection(selection) {
  return `: table
  └ { table: ${selection.tableKey}, anchorCell: ${selection.anchor.key}, focusCell: ${selection.focus.key} }`;
}
function visitTree(currentNode, visitor, indent = []) {
  const childNodes = currentNode.getChildren();
  const childNodesLength = childNodes.length;
  childNodes.forEach((childNode, i) => {
    visitor(childNode, indent.concat(i === childNodesLength - 1 ? SYMBOLS.isLastChild : SYMBOLS.hasNextSibling));
    if ($isElementNode(childNode)) {
      visitTree(childNode, visitor, indent.concat(i === childNodesLength - 1 ? SYMBOLS.ancestorIsLastChild : SYMBOLS.ancestorHasNextSibling));
    }
  });
}
function normalize(text, obfuscateText = false) {
  const textToPrint = Object.entries(NON_SINGLE_WIDTH_CHARS_REPLACEMENT).reduce((acc, [key, value]) => acc.replace(new RegExp(key, "g"), String(value)), text);
  if (obfuscateText) {
    return textToPrint.replace(/[^\s]/g, "*");
  }
  return textToPrint;
}
function printNode(node, customPrintNode, obfuscateText = false) {
  const customPrint = customPrintNode ? customPrintNode(node, obfuscateText) : void 0;
  if (customPrint !== void 0 && customPrint.length > 0) {
    return customPrint;
  }
  if ($isTextNode(node)) {
    const text = node.getTextContent();
    const title = text.length === 0 ? "(empty)" : `"${normalize(text, obfuscateText)}"`;
    const properties = printAllTextNodeProperties(node);
    return [title, properties.length !== 0 ? `{ ${properties} }` : null].filter(Boolean).join(" ").trim();
  } else if ($isLinkNode(node)) {
    const link = node.getURL();
    const title = link.length === 0 ? "(empty)" : `"${normalize(link, obfuscateText)}"`;
    const properties = printAllLinkNodeProperties(node);
    return [title, properties.length !== 0 ? `{ ${properties} }` : null].filter(Boolean).join(" ").trim();
  } else if ($isMarkNode(node)) {
    return `ids: [ ${node.getIDs().join(", ")} ]`;
  } else if ($isParagraphNode(node)) {
    const formatText = printTextFormatProperties(node);
    let paragraphData = formatText !== "" ? `{ ${formatText} }` : "";
    paragraphData += node.__style ? `(${node.__style})` : "";
    return paragraphData;
  } else {
    return "";
  }
}
function printTextFormatProperties(nodeOrSelection) {
  let str = FORMAT_PREDICATES_PARAGRAPH.map((predicate) => predicate(nodeOrSelection)).filter(Boolean).join(", ").toLocaleLowerCase();
  if (str !== "") {
    str = "format: " + str;
  }
  return str;
}
function printAllTextNodeProperties(node) {
  return [printFormatProperties(node), printDetailProperties(node), printModeProperties(node), printStateProperties(node)].filter(Boolean).join(", ");
}
function printAllLinkNodeProperties(node) {
  return [printTargetProperties(node), printRelProperties(node), printTitleProperties(node), printStateProperties(node)].filter(Boolean).join(", ");
}
function printDetailProperties(nodeOrSelection) {
  let str = DETAIL_PREDICATES.map((predicate) => predicate(nodeOrSelection)).filter(Boolean).join(", ").toLocaleLowerCase();
  if (str !== "") {
    str = "detail: " + str;
  }
  return str;
}
function printModeProperties(nodeOrSelection) {
  let str = MODE_PREDICATES.map((predicate) => predicate(nodeOrSelection)).filter(Boolean).join(", ").toLocaleLowerCase();
  if (str !== "") {
    str = "mode: " + str;
  }
  return str;
}
function printFormatProperties(nodeOrSelection) {
  let str = FORMAT_PREDICATES.map((predicate) => predicate(nodeOrSelection)).filter(Boolean).join(", ").toLocaleLowerCase();
  if (str !== "") {
    str = "format: " + str;
  }
  return str;
}
function printTargetProperties(node) {
  let str = node.getTarget();
  if (str != null) {
    str = "target: " + str;
  }
  return str;
}
function printRelProperties(node) {
  let str = node.getRel();
  if (str != null) {
    str = "rel: " + str;
  }
  return str;
}
function printTitleProperties(node) {
  let str = node.getTitle();
  if (str != null) {
    str = "title: " + str;
  }
  return str;
}
function printStateProperties(node) {
  if (!node.__state) {
    return false;
  }
  const states = [];
  for (const [stateType, value] of node.__state.knownState.entries()) {
    if (stateType.isEqual(value, stateType.defaultValue)) {
      continue;
    }
    const textValue = JSON.stringify(stateType.unparse(value));
    states.push(`[${stateType.key}: ${textValue}]`);
  }
  let str = states.join(",");
  if (str !== "") {
    str = "state: " + str;
  }
  return str;
}
function $printSelectedCharsLine({
  indent,
  isSelected,
  node,
  nodeKeyDisplay,
  selection,
  typeDisplay
}) {
  if (!$isTextNode(node) || !$isRangeSelection(selection) || !isSelected || $isElementNode(node)) {
    return "";
  }
  const anchor = selection.anchor;
  const focus = selection.focus;
  if (node.getTextContent() === "" || anchor.getNode() === selection.focus.getNode() && anchor.offset === focus.offset) {
    return "";
  }
  const [start, end] = $getSelectionStartEnd(node, selection);
  if (start === end) {
    return "";
  }
  const selectionLastIndent = indent[indent.length - 1] === SYMBOLS.hasNextSibling ? SYMBOLS.ancestorHasNextSibling : SYMBOLS.ancestorIsLastChild;
  const indentionChars = [...indent.slice(0, indent.length - 1), selectionLastIndent];
  const unselectedChars = Array(start + 1).fill(" ");
  const selectedChars = Array(end - start).fill(SYMBOLS.selectedChar);
  const paddingLength = typeDisplay.length + 2;
  const nodePrintSpaces = Array(nodeKeyDisplay.length + paddingLength).fill(" ");
  return [SYMBOLS.selectedLine, indentionChars.join(" "), [...nodePrintSpaces, ...unselectedChars, ...selectedChars].join("")].join(" ") + "\n";
}
function printPrettyHTML(str) {
  const div = document.createElement("div");
  div.innerHTML = str.trim();
  return prettifyHTML(div, 0).innerHTML;
}
function prettifyHTML(node, level) {
  const indentBefore = new Array(level++ + 1).join("  ");
  const indentAfter = new Array(level - 1).join("  ");
  let textNode;
  for (let i = 0; i < node.children.length; i++) {
    textNode = document.createTextNode("\n" + indentBefore);
    node.insertBefore(textNode, node.children[i]);
    prettifyHTML(node.children[i], level);
    if (node.lastElementChild === node.children[i]) {
      textNode = document.createTextNode("\n" + indentAfter);
      node.appendChild(textNode);
    }
  }
  return node;
}
function $getSelectionStartEnd(node, selection) {
  const anchorAndFocus = selection.getStartEndPoints();
  if ($isNodeSelection(selection) || anchorAndFocus === null) {
    return [-1, -1];
  }
  const [anchor, focus] = anchorAndFocus;
  const textContent = node.getTextContent();
  const textLength = textContent.length;
  let start = -1;
  let end = -1;
  if (anchor.type === "text" && focus.type === "text") {
    const anchorNode = anchor.getNode();
    const focusNode = focus.getNode();
    if (anchorNode === focusNode && node === anchorNode && anchor.offset !== focus.offset) {
      [start, end] = anchor.offset < focus.offset ? [anchor.offset, focus.offset] : [focus.offset, anchor.offset];
    } else if (node === anchorNode) {
      [start, end] = anchorNode.isBefore(focusNode) ? [anchor.offset, textLength] : [0, anchor.offset];
    } else if (node === focusNode) {
      [start, end] = focusNode.isBefore(anchorNode) ? [focus.offset, textLength] : [0, focus.offset];
    } else {
      [start, end] = [0, textLength];
    }
  }
  const numNonSingleWidthCharBeforeSelection = (textContent.slice(0, start).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []).length;
  const numNonSingleWidthCharInSelection = (textContent.slice(start, end).match(NON_SINGLE_WIDTH_CHARS_REGEX) || []).length;
  return [start + numNonSingleWidthCharBeforeSelection, end + numNonSingleWidthCharBeforeSelection + numNonSingleWidthCharInSelection];
}
var LARGE_EDITOR_STATE_SIZE = 1e3;
var TreeView = (0, import_react.forwardRef)(function TreeViewWrapped({
  treeTypeButtonClassName,
  timeTravelButtonClassName,
  timeTravelPanelSliderClassName,
  timeTravelPanelButtonClassName,
  viewClassName,
  timeTravelPanelClassName,
  editorState,
  setEditorState,
  setEditorReadOnly,
  generateContent: generateContent2,
  commandsLog = []
}, ref) {
  const [timeStampedEditorStates, setTimeStampedEditorStates] = (0, import_react.useState)([]);
  const [content, setContent] = (0, import_react.useState)("");
  const [timeTravelEnabled, setTimeTravelEnabled] = (0, import_react.useState)(false);
  const [showExportDOM, setShowExportDOM] = (0, import_react.useState)(false);
  const playingIndexRef = (0, import_react.useRef)(0);
  const inputRef = (0, import_react.useRef)(null);
  const [isPlaying, setIsPlaying] = (0, import_react.useState)(false);
  const [isLimited, setIsLimited] = (0, import_react.useState)(false);
  const [showLimited, setShowLimited] = (0, import_react.useState)(false);
  const lastEditorStateRef = (0, import_react.useRef)(null);
  const lastCommandsLogRef = (0, import_react.useRef)([]);
  const lastGenerationID = (0, import_react.useRef)(0);
  const generateTree = (0, import_react.useCallback)((exportDOM) => {
    const myID = ++lastGenerationID.current;
    generateContent2(exportDOM).then((treeText) => {
      if (myID === lastGenerationID.current) {
        setContent(treeText);
      }
    }).catch((err) => {
      if (myID === lastGenerationID.current) {
        setContent(`Error rendering tree: ${err.message}

Stack:
${err.stack}`);
      }
    });
  }, [generateContent2]);
  (0, import_react.useEffect)(() => {
    if (!showLimited && editorState._nodeMap.size > LARGE_EDITOR_STATE_SIZE) {
      setIsLimited(true);
      if (!showLimited) {
        return;
      }
    }
    const shouldUpdate = lastEditorStateRef.current !== editorState || lastCommandsLogRef.current !== commandsLog;
    if (shouldUpdate) {
      const isEditorStateChange = lastEditorStateRef.current !== editorState;
      lastEditorStateRef.current = editorState;
      lastCommandsLogRef.current = commandsLog;
      generateTree(showExportDOM);
      if (!timeTravelEnabled && isEditorStateChange) {
        setTimeStampedEditorStates((currentEditorStates) => [...currentEditorStates, [Date.now(), editorState]]);
      }
    }
  }, [editorState, generateTree, showExportDOM, showLimited, timeTravelEnabled, commandsLog]);
  const totalEditorStates = timeStampedEditorStates.length;
  (0, import_react.useEffect)(() => {
    if (isPlaying) {
      let timeoutId;
      const play = () => {
        const currentIndex = playingIndexRef.current;
        if (currentIndex === totalEditorStates - 1) {
          setIsPlaying(false);
          return;
        }
        const currentTime = timeStampedEditorStates[currentIndex][0];
        const nextTime = timeStampedEditorStates[currentIndex + 1][0];
        const timeDiff = nextTime - currentTime;
        timeoutId = setTimeout(() => {
          playingIndexRef.current++;
          const index = playingIndexRef.current;
          const input = inputRef.current;
          if (input !== null) {
            input.value = String(index);
          }
          setEditorState(timeStampedEditorStates[index][1]);
          play();
        }, timeDiff);
      };
      play();
      return () => {
        clearTimeout(timeoutId);
      };
    }
  }, [timeStampedEditorStates, isPlaying, totalEditorStates, setEditorState]);
  const handleExportModeToggleClick = () => {
    generateTree(!showExportDOM);
    setShowExportDOM(!showExportDOM);
  };
  return (0, import_jsx_runtime.jsxs)("div", {
    className: viewClassName,
    children: [!showLimited && isLimited ? (0, import_jsx_runtime.jsxs)("div", {
      style: {
        padding: 20
      },
      children: [(0, import_jsx_runtime.jsx)("span", {
        style: {
          marginRight: 20
        },
        children: "Detected large EditorState, this can impact debugging performance."
      }), (0, import_jsx_runtime.jsx)("button", {
        onClick: () => {
          setShowLimited(true);
        },
        style: {
          background: "transparent",
          border: "1px solid white",
          color: "white",
          cursor: "pointer",
          padding: 5
        },
        children: "Show full tree"
      })]
    }) : null, !showLimited ? (0, import_jsx_runtime.jsx)("button", {
      onClick: () => handleExportModeToggleClick(),
      className: treeTypeButtonClassName,
      type: "button",
      children: showExportDOM ? "Tree" : "Export DOM"
    }) : null, !timeTravelEnabled && (showLimited || !isLimited) && totalEditorStates > 2 && (0, import_jsx_runtime.jsx)("button", {
      onClick: () => {
        setEditorReadOnly(true);
        playingIndexRef.current = totalEditorStates - 1;
        setTimeTravelEnabled(true);
      },
      className: timeTravelButtonClassName,
      type: "button",
      children: "Time Travel"
    }), (showLimited || !isLimited) && (0, import_jsx_runtime.jsx)("pre", {
      ref,
      children: content
    }), timeTravelEnabled && (showLimited || !isLimited) && (0, import_jsx_runtime.jsxs)("div", {
      className: timeTravelPanelClassName,
      children: [(0, import_jsx_runtime.jsx)("button", {
        className: timeTravelPanelButtonClassName,
        onClick: () => {
          if (playingIndexRef.current === totalEditorStates - 1) {
            playingIndexRef.current = 1;
          }
          setIsPlaying(!isPlaying);
        },
        type: "button",
        children: isPlaying ? "Pause" : "Play"
      }), (0, import_jsx_runtime.jsx)("input", {
        className: timeTravelPanelSliderClassName,
        ref: inputRef,
        onChange: (event) => {
          const editorStateIndex = Number(event.target.value);
          const timeStampedEditorState = timeStampedEditorStates[editorStateIndex];
          if (timeStampedEditorState) {
            playingIndexRef.current = editorStateIndex;
            setEditorState(timeStampedEditorState[1]);
          }
        },
        type: "range",
        min: "1",
        max: totalEditorStates - 1
      }), (0, import_jsx_runtime.jsx)("button", {
        className: timeTravelPanelButtonClassName,
        onClick: () => {
          setEditorReadOnly(false);
          const index = timeStampedEditorStates.length - 1;
          const timeStampedEditorState = timeStampedEditorStates[index];
          setEditorState(timeStampedEditorState[1]);
          const input = inputRef.current;
          if (input !== null) {
            input.value = String(index);
          }
          setTimeTravelEnabled(false);
          setIsPlaying(false);
        },
        type: "button",
        children: "Exit"
      })]
    })]
  });
});
function registerLexicalCommandLogger(editor, setLoggedCommands) {
  const unregisterCommandListeners = /* @__PURE__ */ new Set();
  let i = 0;
  for (const [command] of editor._commands) {
    unregisterCommandListeners.add(editor.registerCommand(command, (payload) => {
      setLoggedCommands((state) => {
        i += 1;
        const newState = [...state];
        newState.push({
          index: i,
          payload,
          type: command.type ? command.type : "UNKNOWN"
        });
        if (newState.length > 10) {
          newState.shift();
        }
        return newState;
      });
      return false;
    }, COMMAND_PRIORITY_CRITICAL));
  }
  return () => unregisterCommandListeners.forEach((unregister) => unregister());
}
function useLexicalCommandsLog(editor) {
  const [loggedCommands, setLoggedCommands] = (0, import_react.useState)([]);
  (0, import_react.useEffect)(() => {
    return registerLexicalCommandLogger(editor, setLoggedCommands);
  }, [editor]);
  return (0, import_react.useMemo)(() => loggedCommands, [loggedCommands]);
}

// node_modules/@lexical/react/LexicalTreeView.dev.mjs
var React = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
function TreeView2({
  treeTypeButtonClassName,
  timeTravelButtonClassName,
  timeTravelPanelSliderClassName,
  timeTravelPanelButtonClassName,
  timeTravelPanelClassName,
  viewClassName,
  editor,
  customPrintNode
}) {
  const treeElementRef = React.createRef();
  const [editorCurrentState, setEditorCurrentState] = (0, import_react2.useState)(editor.getEditorState());
  const commandsLog = useLexicalCommandsLog(editor);
  (0, import_react2.useEffect)(() => {
    return mergeRegister(editor.registerUpdateListener(({
      editorState
    }) => {
      setEditorCurrentState(editorState);
    }), editor.registerEditableListener(() => {
      setEditorCurrentState(editor.getEditorState());
    }));
  }, [editor]);
  (0, import_react2.useEffect)(() => {
    const element = treeElementRef.current;
    if (element !== null) {
      element.__lexicalEditor = editor;
      return () => {
        element.__lexicalEditor = null;
      };
    }
  }, [editor, treeElementRef]);
  const handleEditorReadOnly = (isReadonly) => {
    const rootElement = editor.getRootElement();
    if (rootElement == null) {
      return;
    }
    rootElement.contentEditable = isReadonly ? "false" : "true";
  };
  return (0, import_jsx_runtime2.jsx)(TreeView, {
    treeTypeButtonClassName,
    timeTravelButtonClassName,
    timeTravelPanelSliderClassName,
    timeTravelPanelButtonClassName,
    viewClassName,
    timeTravelPanelClassName,
    setEditorReadOnly: handleEditorReadOnly,
    editorState: editorCurrentState,
    setEditorState: (state) => editor.setEditorState(state),
    generateContent: async function(exportDOM) {
      return generateContent(editor, commandsLog, exportDOM, customPrintNode);
    },
    ref: treeElementRef,
    commandsLog
  });
}
export {
  TreeView2 as TreeView
};
//# sourceMappingURL=@lexical_react_LexicalTreeView.js.map
